/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mnsc_data_types.h"

namespace meituan_mns {

int _kProtocolsValues[] = {
  Protocols::THRIFT,
  Protocols::HTTP
};
const char* _kProtocolsNames[] = {
  "THRIFT",
  "HTTP"
};
const std::map<int, const char*> _Protocols_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kProtocolsValues, _kProtocolsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* MNSResponse::ascii_fingerprint = "262B7A6EE88301D8EA2B9CBECB4AF401";
const uint8_t MNSResponse::binary_fingerprint[16] = {0x26,0x2B,0x7A,0x6E,0xE8,0x83,0x01,0xD8,0xEA,0x2B,0x9C,0xBE,0xCB,0x4A,0xF4,0x01};

uint32_t MNSResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultMNSCache.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->defaultMNSCache.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->defaultMNSCache[_i4].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.defaultMNSCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNSResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MNSResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.defaultMNSCache) {
    xfer += oprot->writeFieldBegin("defaultMNSCache", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultMNSCache.size()));
      std::vector<SGService> ::const_iterator _iter5;
      for (_iter5 = this->defaultMNSCache.begin(); _iter5 != this->defaultMNSCache.end(); ++_iter5)
      {
        xfer += (*_iter5).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* MNSBatchResponse::ascii_fingerprint = "C0A3C40A83F3EC7069EF8B80B7669355";
const uint8_t MNSBatchResponse::binary_fingerprint[16] = {0xC0,0xA3,0xC4,0x0A,0x83,0xF3,0xEC,0x70,0x69,0xEF,0x8B,0x80,0xB7,0x66,0x93,0x55};

uint32_t MNSBatchResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cache.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::map<std::string, std::vector<SGService> > & _val12 = this->cache[_key11];
              {
                _val12.clear();
                uint32_t _size13;
                ::apache::thrift::protocol::TType _ktype14;
                ::apache::thrift::protocol::TType _vtype15;
                iprot->readMapBegin(_ktype14, _vtype15, _size13);
                uint32_t _i17;
                for (_i17 = 0; _i17 < _size13; ++_i17)
                {
                  std::string _key18;
                  xfer += iprot->readString(_key18);
                  std::vector<SGService> & _val19 = _val12[_key18];
                  {
                    _val19.clear();
                    uint32_t _size20;
                    ::apache::thrift::protocol::TType _etype23;
                    iprot->readListBegin(_etype23, _size20);
                    _val19.resize(_size20);
                    uint32_t _i24;
                    for (_i24 = 0; _i24 < _size20; ++_i24)
                    {
                      xfer += _val19[_i24].read(iprot);
                    }
                    iprot->readListEnd();
                  }
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          this->__isset.cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNSBatchResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MNSBatchResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.cache) {
    xfer += oprot->writeFieldBegin("cache", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->cache.size()));
      std::map<std::string, std::map<std::string, std::vector<SGService> > > ::const_iterator _iter25;
      for (_iter25 = this->cache.begin(); _iter25 != this->cache.end(); ++_iter25)
      {
        xfer += oprot->writeString(_iter25->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter25->second.size()));
          std::map<std::string, std::vector<SGService> > ::const_iterator _iter26;
          for (_iter26 = _iter25->second.begin(); _iter26 != _iter25->second.end(); ++_iter26)
          {
            xfer += oprot->writeString(_iter26->first);
            {
              xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter26->second.size()));
              std::vector<SGService> ::const_iterator _iter27;
              for (_iter27 = _iter26->second.begin(); _iter27 != _iter26->second.end(); ++_iter27)
              {
                xfer += (*_iter27).write(oprot);
              }
              xfer += oprot->writeListEnd();
            }
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* AppKeyListResponse::ascii_fingerprint = "93CC3D1E71866966C22792AABF4C3815";
const uint8_t AppKeyListResponse::binary_fingerprint[16] = {0x93,0xCC,0x3D,0x1E,0x71,0x86,0x69,0x66,0xC2,0x27,0x92,0xAA,0xBF,0x4C,0x38,0x15};

uint32_t AppKeyListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->appKeyList.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            iprot->readListBegin(_etype31, _size28);
            this->appKeyList.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->appKeyList[_i32]);
            }
            iprot->readListEnd();
          }
          this->__isset.appKeyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppKeyListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AppKeyListResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.appKeyList) {
    xfer += oprot->writeFieldBegin("appKeyList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->appKeyList.size()));
      std::vector<std::string> ::const_iterator _iter33;
      for (_iter33 = this->appKeyList.begin(); _iter33 != this->appKeyList.end(); ++_iter33)
      {
        xfer += oprot->writeString((*_iter33));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* MnsRequest::ascii_fingerprint = "38C252E94E93B69D04EB3A6EE2F9EDFB";
const uint8_t MnsRequest::binary_fingerprint[16] = {0x38,0xC2,0x52,0xE9,0x4E,0x93,0xB6,0x9D,0x04,0xEB,0x3A,0x6E,0xE2,0xF9,0xED,0xFB};

uint32_t MnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->protoctol = (Protocols::type)ecast34;
          this->__isset.protoctol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->env);
          this->__isset.env = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MnsRequest");
  xfer += oprot->writeFieldBegin("protoctol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protoctol);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("env", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->env);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace
