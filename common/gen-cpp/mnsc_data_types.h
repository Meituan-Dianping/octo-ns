/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef mnsc_data_TYPES_H
#define mnsc_data_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>

#include "naming_common_types.h"


namespace meituan_mns {

struct Protocols {
  enum type {
    THRIFT = 0,
    HTTP = 1
  };
};

extern const std::map<int, const char*> _Protocols_VALUES_TO_NAMES;

typedef class  ::meituan_mns::SGService SGService;

typedef struct _MNSResponse__isset {
  _MNSResponse__isset() : defaultMNSCache(false), version(false) {}
  bool defaultMNSCache;
  bool version;
} _MNSResponse__isset;

class MNSResponse {
 public:

  static const char* ascii_fingerprint; // = "262B7A6EE88301D8EA2B9CBECB4AF401";
  static const uint8_t binary_fingerprint[16]; // = {0x26,0x2B,0x7A,0x6E,0xE8,0x83,0x01,0xD8,0xEA,0x2B,0x9C,0xBE,0xCB,0x4A,0xF4,0x01};

  MNSResponse() : code(200), version("") {
  }

  virtual ~MNSResponse() throw() {}

  int32_t code;
  std::vector<SGService>  defaultMNSCache;
  std::string version;

  _MNSResponse__isset __isset;

  void __set_code(const int32_t val) {
    code = val;
  }

  void __set_defaultMNSCache(const std::vector<SGService> & val) {
    defaultMNSCache = val;
    __isset.defaultMNSCache = true;
  }

  void __set_version(const std::string& val) {
    version = val;
    __isset.version = true;
  }

  bool operator == (const MNSResponse & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (__isset.defaultMNSCache != rhs.__isset.defaultMNSCache)
      return false;
    else if (__isset.defaultMNSCache && !(defaultMNSCache == rhs.defaultMNSCache))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const MNSResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MNSResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MNSBatchResponse__isset {
  _MNSBatchResponse__isset() : cache(false) {}
  bool cache;
} _MNSBatchResponse__isset;

class MNSBatchResponse {
 public:

  static const char* ascii_fingerprint; // = "C0A3C40A83F3EC7069EF8B80B7669355";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0xA3,0xC4,0x0A,0x83,0xF3,0xEC,0x70,0x69,0xEF,0x8B,0x80,0xB7,0x66,0x93,0x55};

  MNSBatchResponse() : code(200) {
  }

  virtual ~MNSBatchResponse() throw() {}

  int32_t code;
  std::map<std::string, std::map<std::string, std::vector<SGService> > >  cache;

  _MNSBatchResponse__isset __isset;

  void __set_code(const int32_t val) {
    code = val;
  }

  void __set_cache(const std::map<std::string, std::map<std::string, std::vector<SGService> > > & val) {
    cache = val;
    __isset.cache = true;
  }

  bool operator == (const MNSBatchResponse & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (__isset.cache != rhs.__isset.cache)
      return false;
    else if (__isset.cache && !(cache == rhs.cache))
      return false;
    return true;
  }
  bool operator != (const MNSBatchResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MNSBatchResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AppKeyListResponse__isset {
  _AppKeyListResponse__isset() : appKeyList(false) {}
  bool appKeyList;
} _AppKeyListResponse__isset;

class AppKeyListResponse {
 public:

  static const char* ascii_fingerprint; // = "93CC3D1E71866966C22792AABF4C3815";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0xCC,0x3D,0x1E,0x71,0x86,0x69,0x66,0xC2,0x27,0x92,0xAA,0xBF,0x4C,0x38,0x15};

  AppKeyListResponse() : code(200) {
  }

  virtual ~AppKeyListResponse() throw() {}

  int32_t code;
  std::vector<std::string>  appKeyList;

  _AppKeyListResponse__isset __isset;

  void __set_code(const int32_t val) {
    code = val;
  }

  void __set_appKeyList(const std::vector<std::string> & val) {
    appKeyList = val;
    __isset.appKeyList = true;
  }

  bool operator == (const AppKeyListResponse & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (__isset.appKeyList != rhs.__isset.appKeyList)
      return false;
    else if (__isset.appKeyList && !(appKeyList == rhs.appKeyList))
      return false;
    return true;
  }
  bool operator != (const AppKeyListResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AppKeyListResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MnsRequest__isset {
  _MnsRequest__isset() : protoctol(false), appkey(false), env(false) {}
  bool protoctol;
  bool appkey;
  bool env;
} _MnsRequest__isset;

class MnsRequest {
 public:

  static const char* ascii_fingerprint; // = "38C252E94E93B69D04EB3A6EE2F9EDFB";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0xC2,0x52,0xE9,0x4E,0x93,0xB6,0x9D,0x04,0xEB,0x3A,0x6E,0xE2,0xF9,0xED,0xFB};

  MnsRequest() : protoctol((Protocols::type)0), appkey(""), env("") {
  }

  virtual ~MnsRequest() throw() {}

  Protocols::type protoctol;
  std::string appkey;
  std::string env;

  _MnsRequest__isset __isset;

  void __set_protoctol(const Protocols::type val) {
    protoctol = val;
  }

  void __set_appkey(const std::string& val) {
    appkey = val;
  }

  void __set_env(const std::string& val) {
    env = val;
  }

  bool operator == (const MnsRequest & rhs) const
  {
    if (!(protoctol == rhs.protoctol))
      return false;
    if (!(appkey == rhs.appkey))
      return false;
    if (!(env == rhs.env))
      return false;
    return true;
  }
  bool operator != (const MnsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MnsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

} // namespace

#endif
