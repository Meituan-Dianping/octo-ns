/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "unified_protocol_types.h"

namespace meituan_mns {

int _kMessageTypeValues[] = {
  MessageType::Normal,
  MessageType::NormalHeartbeat,
  MessageType::ScannerHeartbeat
};
const char* _kMessageTypeNames[] = {
  "Normal",
  "NormalHeartbeat",
  "ScannerHeartbeat"
};
const std::map<int, const char*> _MessageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMessageTypeValues, _kMessageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompressTypeValues[] = {
  CompressType::None,
  CompressType::Snappy,
  CompressType::Gzip
};
const char* _kCompressTypeNames[] = {
  "None",
  "Snappy",
  "Gzip"
};
const std::map<int, const char*> _CompressType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCompressTypeValues, _kCompressTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCallTypeValues[] = {
  CallType::Reply,
  CallType::NoReply
};
const char* _kCallTypeNames[] = {
  "Reply",
  "NoReply"
};
const std::map<int, const char*> _CallType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCallTypeValues, _kCallTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStatusCodesValues[] = {
  StatusCodes::Success,
  StatusCodes::ApplicationException,
  StatusCodes::RuntimeException,
  StatusCodes::RpcException,
  StatusCodes::TransportException,
  StatusCodes::ProtocolException,
  StatusCodes::DegradeException,
  StatusCodes::SecurityException,
  StatusCodes::ServiceException,
  StatusCodes::RemoteException
};
const char* _kStatusCodesNames[] = {
  "Success",
  "ApplicationException",
  "RuntimeException",
  "RpcException",
  "TransportException",
  "ProtocolException",
  "DegradeException",
  "SecurityException",
  "ServiceException",
  "RemoteException"
};
const std::map<int, const char*> _StatusCodes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kStatusCodesValues, _kStatusCodesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* RequestInfo::ascii_fingerprint = "59AD75927B39FBAC91B35C663FDB29CD";
const uint8_t RequestInfo::binary_fingerprint[16] = {0x59,0xAD,0x75,0x92,0x7B,0x39,0xFB,0xAC,0x91,0xB3,0x5C,0x66,0x3F,0xDB,0x29,0xCD};

uint32_t RequestInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serviceName = false;
  bool isset_sequenceId = false;
  bool isset_callType = false;
  bool isset_timeout = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serviceName);
          isset_serviceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sequenceId);
          isset_sequenceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->callType);
          isset_callType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          isset_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serviceName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sequenceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_callType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeout)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RequestInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RequestInfo");
  xfer += oprot->writeFieldBegin("serviceName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serviceName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("sequenceId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sequenceId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("callType", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->callType);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->timeout);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResponseInfo::ascii_fingerprint = "C6D3CA4A6A1EB8E865A6A00B60176AA8";
const uint8_t ResponseInfo::binary_fingerprint[16] = {0xC6,0xD3,0xCA,0x4A,0x6A,0x1E,0xB8,0xE8,0x65,0xA6,0xA0,0x0B,0x60,0x17,0x6A,0xA8};

uint32_t ResponseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sequenceId = false;
  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sequenceId);
          isset_sequenceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->status);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sequenceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResponseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResponseInfo");
  xfer += oprot->writeFieldBegin("sequenceId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sequenceId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->status);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TraceInfo::ascii_fingerprint = "ABB2B5AA298E9052ED1A5DE871EF9527";
const uint8_t TraceInfo::binary_fingerprint[16] = {0xAB,0xB2,0xB5,0xAA,0x29,0x8E,0x90,0x52,0xED,0x1A,0x5D,0xE8,0x71,0xEF,0x95,0x27};

uint32_t TraceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clientAppkey = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientAppkey);
          isset_clientAppkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->traceId);
          this->__isset.traceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spanId);
          this->__isset.spanId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rootMessageId);
          this->__isset.rootMessageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->currentMessageId);
          this->__isset.currentMessageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverMessageId);
          this->__isset.serverMessageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->debug);
          this->__isset.debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sample);
          this->__isset.sample = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientIp);
          this->__isset.clientIp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clientAppkey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TraceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TraceInfo");
  xfer += oprot->writeFieldBegin("clientAppkey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clientAppkey);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.traceId) {
    xfer += oprot->writeFieldBegin("traceId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->traceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.spanId) {
    xfer += oprot->writeFieldBegin("spanId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->spanId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rootMessageId) {
    xfer += oprot->writeFieldBegin("rootMessageId", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->rootMessageId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.currentMessageId) {
    xfer += oprot->writeFieldBegin("currentMessageId", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->currentMessageId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serverMessageId) {
    xfer += oprot->writeFieldBegin("serverMessageId", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->serverMessageId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug) {
    xfer += oprot->writeFieldBegin("debug", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->debug);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sample) {
    xfer += oprot->writeFieldBegin("sample", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->sample);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clientIp) {
    xfer += oprot->writeFieldBegin("clientIp", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->clientIp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* LoadInfo::ascii_fingerprint = "F424555CA1CEF935A4729C49DC664047";
const uint8_t LoadInfo::binary_fingerprint[16] = {0xF4,0x24,0x55,0x5C,0xA1,0xCE,0xF9,0x35,0xA4,0x72,0x9C,0x49,0xDC,0x66,0x40,0x47};

uint32_t LoadInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->averageLoad);
          this->__isset.averageLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->oldGC);
          this->__isset.oldGC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threadNum);
          this->__isset.threadNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queueSize);
          this->__isset.queueSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->methodQpsMap.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              double& _val6 = this->methodQpsMap[_key5];
              xfer += iprot->readDouble(_val6);
            }
            iprot->readMapEnd();
          }
          this->__isset.methodQpsMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoadInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LoadInfo");
  if (this->__isset.averageLoad) {
    xfer += oprot->writeFieldBegin("averageLoad", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->averageLoad);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.oldGC) {
    xfer += oprot->writeFieldBegin("oldGC", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->oldGC);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.threadNum) {
    xfer += oprot->writeFieldBegin("threadNum", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->threadNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queueSize) {
    xfer += oprot->writeFieldBegin("queueSize", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queueSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.methodQpsMap) {
    xfer += oprot->writeFieldBegin("methodQpsMap", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->methodQpsMap.size()));
      std::map<std::string, double> ::const_iterator _iter7;
      for (_iter7 = this->methodQpsMap.begin(); _iter7 != this->methodQpsMap.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeDouble(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HeartbeatInfo::ascii_fingerprint = "EF43E82D9230E1225E24787F74163831";
const uint8_t HeartbeatInfo::binary_fingerprint[16] = {0xEF,0x43,0xE8,0x2D,0x92,0x30,0xE1,0x22,0x5E,0x24,0x78,0x7F,0x74,0x16,0x38,0x31};

uint32_t HeartbeatInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sendTime);
          this->__isset.sendTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->loadInfo.read(iprot);
          this->__isset.loadInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HeartbeatInfo");
  if (this->__isset.appkey) {
    xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->appkey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sendTime) {
    xfer += oprot->writeFieldBegin("sendTime", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->sendTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loadInfo) {
    xfer += oprot->writeFieldBegin("loadInfo", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->loadInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Header::ascii_fingerprint = "449EC0AD8F982561B4D899B14FB0084B";
const uint8_t Header::binary_fingerprint[16] = {0x44,0x9E,0xC0,0xAD,0x8F,0x98,0x25,0x61,0xB4,0xD8,0x99,0xB1,0x4F,0xB0,0x08,0x4B};

uint32_t Header::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->messageType);
          this->__isset.messageType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestInfo.read(iprot);
          this->__isset.requestInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->responseInfo.read(iprot);
          this->__isset.responseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->traceInfo.read(iprot);
          this->__isset.traceInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->globalContext.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              std::string _key13;
              xfer += iprot->readString(_key13);
              std::string& _val14 = this->globalContext[_key13];
              xfer += iprot->readString(_val14);
            }
            iprot->readMapEnd();
          }
          this->__isset.globalContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->localContext.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _ktype16;
            ::apache::thrift::protocol::TType _vtype17;
            iprot->readMapBegin(_ktype16, _vtype17, _size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              std::string _key20;
              xfer += iprot->readString(_key20);
              std::string& _val21 = this->localContext[_key20];
              xfer += iprot->readString(_val21);
            }
            iprot->readMapEnd();
          }
          this->__isset.localContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->heartbeatInfo.read(iprot);
          this->__isset.heartbeatInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Header");
  if (this->__isset.messageType) {
    xfer += oprot->writeFieldBegin("messageType", ::apache::thrift::protocol::T_BYTE, 1);
    xfer += oprot->writeByte(this->messageType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requestInfo) {
    xfer += oprot->writeFieldBegin("requestInfo", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->requestInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.responseInfo) {
    xfer += oprot->writeFieldBegin("responseInfo", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->responseInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.traceInfo) {
    xfer += oprot->writeFieldBegin("traceInfo", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->traceInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.globalContext) {
    xfer += oprot->writeFieldBegin("globalContext", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->globalContext.size()));
      std::map<std::string, std::string> ::const_iterator _iter22;
      for (_iter22 = this->globalContext.begin(); _iter22 != this->globalContext.end(); ++_iter22)
      {
        xfer += oprot->writeString(_iter22->first);
        xfer += oprot->writeString(_iter22->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.localContext) {
    xfer += oprot->writeFieldBegin("localContext", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->localContext.size()));
      std::map<std::string, std::string> ::const_iterator _iter23;
      for (_iter23 = this->localContext.begin(); _iter23 != this->localContext.end(); ++_iter23)
      {
        xfer += oprot->writeString(_iter23->first);
        xfer += oprot->writeString(_iter23->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.heartbeatInfo) {
    xfer += oprot->writeFieldBegin("heartbeatInfo", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->heartbeatInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace
